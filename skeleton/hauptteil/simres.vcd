$date
	Wed Jul  1 14:20:34 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 32 3 value [31:0] $end
$var wire 1 4 usevalue $end
$var wire 1 5 regwrite $end
$var wire 32 6 pc [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 7 memtoreg $end
$var wire 1 8 dojump $end
$var wire 1 9 dobranch $end
$var wire 5 : destreg [4:0] $end
$var wire 1 ; alusrcbimm $end
$var wire 32 < aluout [31:0] $end
$var wire 3 = alucontrol [2:0] $end
$scope module decoder $end
$var wire 32 > instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 ? op [5:0] $end
$var wire 6 @ funct [5:0] $end
$var reg 3 A alucontrol [2:0] $end
$var reg 1 ; alusrcbimm $end
$var reg 5 B destreg [4:0] $end
$var reg 1 9 dobranch $end
$var reg 1 8 dojump $end
$var reg 1 7 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 5 regwrite $end
$var reg 1 4 usevalue $end
$var reg 32 C value [31:0] $end
$upscope $end
$scope module dp $end
$var wire 3 D alucontrol [2:0] $end
$var wire 1 ; alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 E destreg [4:0] $end
$var wire 1 9 dobranch $end
$var wire 32 F instr [31:0] $end
$var wire 1 8 jump $end
$var wire 1 7 memtoreg $end
$var wire 32 G readdata [31:0] $end
$var wire 1 5 regwrite $end
$var wire 1 " reset $end
$var wire 1 4 usevalue $end
$var wire 32 H value [31:0] $end
$var wire 32 I writedata [31:0] $end
$var wire 1 1 zero $end
$var wire 32 J srcbimm [31:0] $end
$var wire 32 K srcb [31:0] $end
$var wire 32 L srca [31:0] $end
$var wire 32 M signimm [31:0] $end
$var wire 32 N result [31:0] $end
$var wire 32 O pc [31:0] $end
$var wire 32 P aluout [31:0] $end
$scope module alu $end
$var wire 3 Q alucontrol [2:0] $end
$var wire 32 R b [31:0] $end
$var wire 32 S a [31:0] $end
$var reg 32 T hi [31:0] $end
$var reg 32 U lo [31:0] $end
$var reg 32 V result [31:0] $end
$var reg 1 1 zero $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 W ra1 [4:0] $end
$var wire 5 X ra2 [4:0] $end
$var wire 5 Y wa3 [4:0] $end
$var wire 32 Z wd3 [31:0] $end
$var wire 1 5 we3 $end
$var wire 32 [ rd2 [31:0] $end
$var wire 32 \ rd1 [31:0] $end
$upscope $end
$scope module pcenv $end
$var wire 1 ! clk $end
$var wire 1 9 dobranch $end
$var wire 1 8 dojump $end
$var wire 26 ] jumptarget [25:0] $end
$var wire 32 ^ progcounter [31:0] $end
$var wire 1 " reset $end
$var wire 32 _ nextpc [31:0] $end
$var wire 32 ` incpc [31:0] $end
$var wire 32 a branchpc [31:0] $end
$var wire 32 b branchoffset [31:0] $end
$var reg 32 c pc [31:0] $end
$scope module pcbranch $end
$var wire 32 d b [31:0] $end
$var wire 1 e cin $end
$var wire 32 f y [31:0] $end
$var wire 1 g cout $end
$var wire 32 h a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 i a [31:0] $end
$var wire 32 j b [31:0] $end
$var wire 1 k cin $end
$var wire 32 l y [31:0] $end
$var wire 1 m cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 n a [15:0] $end
$var wire 32 o y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b1001000110100 o
b1001000110100 n
0m
b10000000000000000000100 l
0k
b100 j
b10000000000000000000000 i
b10000000000000000000100 h
0g
b10000000100100011010100 f
0e
b100100011010000 d
b10000000000000000000000 c
b1001000110100 b
b10000000100100011010100 a
b10000000000000000000100 `
b10000000000000000000100 _
b10000000000000000000000 ^
b10001001000110100 ]
b0 \
b11001010111111101011101010111110 [
b10010001101000000000000000000 Z
b1 Y
b1 X
b0 W
bx V
b0 U
b0 T
b0 S
b1001000110100 R
b100 Q
bx P
b10000000000000000000000 O
b10010001101000000000000000000 N
b1001000110100 M
b0 L
b11001010111111101011101010111110 K
b1001000110100 J
b11001010111111101011101010111110 I
b10010001101000000000000000000 H
bx G
b111100000000010001001000110100 F
b1 E
b100 D
b10010001101000000000000000000 C
b1 B
b100 A
b110100 @
b1111 ?
b111100000000010001001000110100 >
b100 =
bx <
1;
b1 :
09
08
07
b10000000000000000000000 6
15
14
b10010001101000000000000000000 3
b11001010111111101011101010111110 2
x1
bx 0
b111100000000010001001000110100 /
b111100000000010001001000110100 .
b0 -
b11001010111111101011101010111110 ,
bx +
bx *
bx )
0(
b111100000000010001001000110100 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
b10010001101000000000000000000 $
b10010001101000000000000000000 ,
b10010001101000000000000000000 2
b10010001101000000000000000000 I
b10010001101000000000000000000 K
b10010001101000000000000000000 [
1!
#5
0"
#6
0!
#8
b1101 *
b10000000000000000001000 _
b10010001101000001001000110100 N
b10010001101000001001000110100 Z
11
b10010001101000001001000110100 )
b10010001101000001001000110100 <
b10010001101000001001000110100 P
b10010001101000001001000110100 V
b10010001101000000000000000000 L
b10010001101000000000000000000 S
b10010001101000000000000000000 \
b10000000100100011011000 a
b10000000100100011011000 f
bx 3
bx C
bx H
04
b110 =
b110 A
b110 D
b110 Q
b1101 ?
b1000010001001000110100 ]
b1 W
b10000000000000000001000 `
b10000000000000000001000 h
b10000000000000000001000 l
b110100001000010001001000110100 '
b110100001000010001001000110100 .
b110100001000010001001000110100 /
b110100001000010001001000110100 >
b110100001000010001001000110100 F
b1 -
b10000000000000000000100 &
b10000000000000000000100 6
b10000000000000000000100 O
b10000000000000000000100 ^
b10000000000000000000100 c
b10000000000000000000100 i
1!
#10
0!
#12
bx N
bx Z
b1 *
b10000000000000000001100 _
b10000 d
b100 J
b100 R
b100 )
b100 <
b100 P
b100 V
b10000000000000000011100 a
b10000000000000000011100 f
b101 =
b101 A
b101 D
b101 Q
17
1(
05
b101011 ?
b100 @
b10000000000000100 ]
b100 M
b100 b
b100 o
b100 n
b0 W
b0 L
b0 S
b0 \
b10010001101000001001000110100 $
b10010001101000001001000110100 ,
b10010001101000001001000110100 2
b10010001101000001001000110100 I
b10010001101000001001000110100 K
b10010001101000001001000110100 [
b10000000000000000001100 `
b10000000000000000001100 h
b10000000000000000001100 l
b10101100000000010000000000000100 '
b10101100000000010000000000000100 .
b10101100000000010000000000000100 /
b10101100000000010000000000000100 >
b10101100000000010000000000000100 F
b10 -
b10000000000000000001000 &
b10000000000000000001000 6
b10000000000000000001000 O
b10000000000000000001000 ^
b10000000000000000001000 c
b10000000000000000001000 i
1!
#14
0!
#16
xg
bx T
bx U
bx _
bx00 d
bx J
bx R
bx L
bx S
bx \
bx $
bx ,
bx 2
bx I
bx K
bx [
bx a
bx f
b100 =
b100 A
b100 D
b100 Q
x8
x7
x(
x9
x;
bx :
bx B
bx E
bx Y
x5
bx ?
bx @
bx ]
bx M
bx b
bx o
bx n
bx W
bx X
b0x00x000xx0x00000x00x000xx0100 N
b0x00x000xx0x00000x00x000xx0100 Z
b10000000000000000010000 `
b10000000000000000010000 h
b10000000000000000010000 l
bx '
bx .
bx /
bx >
bx F
b11 -
b10000000000000000001100 &
b10000000000000000001100 6
b10000000000000000001100 O
b10000000000000000001100 ^
b10000000000000000001100 c
b10000000000000000001100 i
b10010001101000001001000110100 %
b10010001101000001001000110100 +
b10010001101000001001000110100 0
b10010001101000001001000110100 G
1!
#18
0!
#20
bx `
bx h
bx l
xm
bx -
bx &
bx 6
bx O
bx ^
bx c
bx i
1!
#21
b100000 #
