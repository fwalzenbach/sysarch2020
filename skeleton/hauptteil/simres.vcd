$date
	Thu Jul  2 12:31:47 2020
$end
$version
	Icarus Verilog
$end
$timescale
	1s
$end
$scope module ProcessorTestbench $end
$var reg 1 ! clk $end
$var reg 1 " reset $end
$var integer 32 # i [31:0] $end
$scope module proc $end
$var wire 1 ! clk $end
$var wire 1 " reset $end
$var wire 32 $ writedata [31:0] $end
$var wire 32 % readdata [31:0] $end
$var wire 32 & pc [31:0] $end
$var wire 32 ' instr [31:0] $end
$var wire 1 ( datawrite $end
$var wire 32 ) dataaddr [31:0] $end
$scope module dmem $end
$var wire 6 * addr [5:0] $end
$var wire 1 ! clk $end
$var wire 32 + rd [31:0] $end
$var wire 1 ( we $end
$var wire 32 , wd [31:0] $end
$upscope $end
$scope module imem $end
$var wire 6 - addr [5:0] $end
$var wire 32 . rd [31:0] $end
$upscope $end
$scope module mips $end
$var wire 1 ! clk $end
$var wire 32 / instr [31:0] $end
$var wire 32 0 readdata [31:0] $end
$var wire 1 " reset $end
$var wire 1 1 zero $end
$var wire 32 2 writedata [31:0] $end
$var wire 32 3 value [31:0] $end
$var wire 1 4 usevalue $end
$var wire 1 5 regwrite $end
$var wire 32 6 pc [31:0] $end
$var wire 1 ( memwrite $end
$var wire 1 7 memtoreg $end
$var wire 1 8 link $end
$var wire 1 9 jumpreg $end
$var wire 1 : dojump $end
$var wire 1 ; dobranch $end
$var wire 5 < destreg [4:0] $end
$var wire 1 = alusrcbimm $end
$var wire 32 > aluout [31:0] $end
$var wire 3 ? alucontrol [2:0] $end
$scope module decoder $end
$var wire 32 @ instr [31:0] $end
$var wire 1 1 zero $end
$var wire 6 A op [5:0] $end
$var wire 6 B funct [5:0] $end
$var reg 3 C alucontrol [2:0] $end
$var reg 1 = alusrcbimm $end
$var reg 5 D destreg [4:0] $end
$var reg 1 ; dobranch $end
$var reg 1 : dojump $end
$var reg 1 9 jumpreg $end
$var reg 1 8 link $end
$var reg 1 7 memtoreg $end
$var reg 1 ( memwrite $end
$var reg 1 5 regwrite $end
$var reg 1 4 usevalue $end
$var reg 32 E value [31:0] $end
$upscope $end
$scope module dp $end
$var wire 3 F alucontrol [2:0] $end
$var wire 1 = alusrcbimm $end
$var wire 1 ! clk $end
$var wire 5 G destreg [4:0] $end
$var wire 1 ; dobranch $end
$var wire 32 H instr [31:0] $end
$var wire 1 : jump $end
$var wire 1 9 jumpreg $end
$var wire 1 8 link $end
$var wire 1 7 memtoreg $end
$var wire 32 I readdata [31:0] $end
$var wire 1 5 regwrite $end
$var wire 1 " reset $end
$var wire 1 4 usevalue $end
$var wire 32 J value [31:0] $end
$var wire 32 K writedata [31:0] $end
$var wire 1 1 zero $end
$var wire 32 L srcbimm [31:0] $end
$var wire 32 M srcb [31:0] $end
$var wire 32 N srca [31:0] $end
$var wire 32 O signimm [31:0] $end
$var wire 32 P result [31:0] $end
$var wire 32 Q pc [31:0] $end
$var wire 26 R jumptarget [25:0] $end
$var wire 32 S aluout [31:0] $end
$scope module alu $end
$var wire 3 T alucontrol [2:0] $end
$var wire 32 U b [31:0] $end
$var wire 32 V a [31:0] $end
$var reg 32 W hi [31:0] $end
$var reg 32 X lo [31:0] $end
$var reg 32 Y result [31:0] $end
$var reg 1 1 zero $end
$upscope $end
$scope module gpr $end
$var wire 1 ! clk $end
$var wire 5 Z ra1 [4:0] $end
$var wire 5 [ ra2 [4:0] $end
$var wire 5 \ wa3 [4:0] $end
$var wire 32 ] wd3 [31:0] $end
$var wire 1 5 we3 $end
$var wire 32 ^ rd2 [31:0] $end
$var wire 32 _ rd1 [31:0] $end
$upscope $end
$scope module pcenv $end
$var wire 1 ! clk $end
$var wire 1 ; dobranch $end
$var wire 1 : dojump $end
$var wire 26 ` jumptarget [25:0] $end
$var wire 32 a progcounter [31:0] $end
$var wire 1 " reset $end
$var wire 32 b nextpc [31:0] $end
$var wire 32 c incpc [31:0] $end
$var wire 32 d branchpc [31:0] $end
$var wire 32 e branchoffset [31:0] $end
$var reg 32 f pc [31:0] $end
$scope module pcbranch $end
$var wire 32 g b [31:0] $end
$var wire 1 h cin $end
$var wire 32 i y [31:0] $end
$var wire 1 j cout $end
$var wire 32 k a [31:0] $end
$upscope $end
$scope module pcinc $end
$var wire 32 l a [31:0] $end
$var wire 32 m b [31:0] $end
$var wire 1 n cin $end
$var wire 32 o y [31:0] $end
$var wire 1 p cout $end
$upscope $end
$upscope $end
$scope module se $end
$var wire 16 q a [15:0] $end
$var wire 32 r y [31:0] $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
$dumpvars
b11 r
b11 q
0p
b10000000000000000000100 o
0n
b100 m
b10000000000000000000000 l
b10000000000000000000100 k
0j
b10000000000000000010000 i
0h
b1100 g
b10000000000000000000000 f
b11 e
b10000000000000000010000 d
b10000000000000000000100 c
b10000000000000000001100 b
b10000000000000000000000 a
b100000000000000000011 `
b0 _
b11001010111111101011101010111110 ^
b10000000000000000000100 ]
b11111 \
b10000 [
b0 Z
bx Y
bx X
bx W
b0 V
b11001010111111101011101010111110 U
bx T
bx S
b100000000000000000011 R
b10000000000000000000000 Q
b10000000000000000000100 P
b11 O
b0 N
b11001010111111101011101010111110 M
b11001010111111101011101010111110 L
b11001010111111101011101010111110 K
bx J
bx I
b1100000100000000000000000011 H
b11111 G
bx F
bx E
b11111 D
bx C
b11 B
b11 A
b1100000100000000000000000011 @
bx ?
bx >
0=
b11111 <
0;
1:
09
18
07
b10000000000000000000000 6
15
04
bx 3
b11001010111111101011101010111110 2
x1
bx 0
b1100000100000000000000000011 /
b1100000100000000000000000011 .
b0 -
b11001010111111101011101010111110 ,
bx +
bx *
bx )
0(
b1100000100000000000000000011 '
b10000000000000000000000 &
bx %
b11001010111111101011101010111110 $
b100000 #
1"
1!
$end
#2
0!
#4
1!
#5
0"
#6
0!
#8
b11110 *
11
b1111011 )
b1111011 >
b1111011 S
b1111011 Y
b10000000000000000010000 b
b1111011 L
b1111011 U
b1010000000001111011 R
b1010000000001111011 `
b111101100 g
b10000000000000111111100 d
b10000000000000111111100 i
b101 ?
b101 C
b101 F
b101 T
08
0:
1=
b101 <
b101 D
b101 G
b101 \
b1001 A
b111011 B
b1111011 O
b1111011 e
b1111011 r
b1111011 q
b101 [
b10000000000000000010000 c
b10000000000000000010000 k
b10000000000000000010000 o
b1111011 P
b1111011 ]
b100100000001010000000001111011 '
b100100000001010000000001111011 .
b100100000001010000000001111011 /
b100100000001010000000001111011 @
b100100000001010000000001111011 H
b11 -
b10000000000000000001100 &
b10000000000000000001100 6
b10000000000000000001100 Q
b10000000000000000001100 a
b10000000000000000001100 f
b10000000000000000001100 l
1!
#10
0!
#12
bx P
bx ]
bx *
x1
bx )
bx >
bx S
bx Y
b1000000000000000000010000 b
b10000000000000000000100 R
b10000000000000000000100 `
b100000 g
b0 L
b0 U
b10000000000000000000100 N
b10000000000000000000100 V
b10000000000000000000100 _
b10000000000000000110100 d
b10000000000000000110100 i
bx ?
bx C
bx F
bx T
19
1:
05
0=
bx <
bx D
bx G
bx \
b0 A
b1000 B
b1000 O
b1000 e
b1000 r
b1000 q
b11111 Z
b0 [
b0 $
b0 ,
b0 2
b0 K
b0 M
b0 ^
b10000000000000000010100 c
b10000000000000000010100 k
b10000000000000000010100 o
b11111000000000000000001000 '
b11111000000000000000001000 .
b11111000000000000000001000 /
b11111000000000000000001000 @
b11111000000000000000001000 H
b100 -
b10000000000000000010000 &
b10000000000000000010000 6
b10000000000000000010000 Q
b10000000000000000010000 a
b10000000000000000010000 f
b10000000000000000010000 l
1!
#14
0!
#16
b1000000000000000000110100 d
b1000000000000000000110100 i
b1000000000000000000010100 c
b1000000000000000000010100 k
b1000000000000000000010100 o
b1000000000000000000010000 &
b1000000000000000000010000 6
b1000000000000000000010000 Q
b1000000000000000000010000 a
b1000000000000000000010000 f
b1000000000000000000010000 l
1!
#18
0!
#20
1!
#22
0!
#24
1!
#26
0!
#28
1!
#30
0!
#32
1!
#34
0!
#36
1!
#38
0!
#40
1!
#42
0!
#44
1!
#46
0!
#48
1!
#50
0!
#52
1!
#54
0!
#55
b110 #
